---
layout: post
title: "设计模式原理及应用场景"
date: 2018-01-10
tag: "Java"
detail: 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。
img: 

---

* content
{:toc}

[设计模式源码](https://github.com/zhongyp/Demo/tree/master/src/main/java/com/zhongyp/advanced/pattern)

## 深入浅出设计模式遵循的设计模式原则：

* 封装变化： 找出应用中可能需要变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起。

* 多用组合，少用继承： 组合使系统具有弹性，不仅可以将算法封装成类，还可以在运行是动态的改变行为。

* 针对接口编程，不针对实现编程： 程序利用多态针对超类型（supertype）编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上

* 为交互对象之间的松耦合设计而努力

* 类应该对扩展开放，对修改关闭： 

* 依赖抽象，不要依赖具体类

* 最少知识原则：只和朋友交谈 

* 别找我，我会找你

* 类应该只有一个改变的理由

## 策略模式(stragety)

定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。体现封装变化、多用组合少用继承、针对接口编程，不针对实现编程。

类图：

![类图](https://github.com/zhongyp/zhongyp.github.io/blob/master/files/Strategy.png?raw=true)

Strategy模式有下面的一些优点：

* 相关算法系列 Strategy类层次为Context定义了一系列的可供重用的算法或行为。 继承有助于析取出这些算法中的公共功能。

* 提供了可以替换继承关系的办法： 继承提供了另一种支持多种算法或行为的方法。你可以直接生成一个Context类的子类，从而给它以不同的行为。但这会将行为硬行编制到 Context中，而将算法的实现与Context的实现混合起来,从而使Context难以理解、难以维护和难以扩展，而且还不能动态地改变算法。最后你得到一堆相关的类 , 它们之间的唯一差别是它们所使用的算法或行为。 将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。

* 消除了一些if else条件语句 ：Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一个类中时 ,很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的Strategy类中消除了这些条件语句。含有许多条件语句的代码通常意味着需要使用Strategy模式。

* 实现的选择 Strategy模式可以提供相同行为的不同实现。客户可以根据不同时间 /空间权衡取舍要求从不同策略中进行选择。

Strategy模式缺点:

* 客户端必须知道所有的策略类，并自行决定使用哪一个策略类:  本模式有一个潜在的缺点，就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同。此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时 , 才需要使用Strategy模式。

* Strategy和Context之间的通信开销 ：无论各个ConcreteStrategy实现的算法是简单还是复杂, 它们都共享Strategy定义的接口。因此很可能某些 ConcreteStrategy不会都用到所有通过这个接口传递给它们的信息；简单的 ConcreteStrategy可能不使用其中的任何信息！这就意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样问题 , 那么将需要在Strategy和Context之间更进行紧密的耦合。

* 策略模式将造成产生很多策略类：可以通过使用享元模式在一定程度上减少对象的数量。 增加了对象的数目 Strategy增加了一个应用中的对象的数目。有时你可以将 Strategy实现为可供各Context共享的无状态的对象来减少这一开销。任何其余的状态都由 Context维护。Context在每一次对Strategy对象的请求中都将这个状态传递过去。共享的 Strategy不应在各次调用之间维护状态。

应用场景：比较器Comparator和布局管理器LayoutManager

* 在该比较架构中，Comparator就是一个抽象的策略；一个类实现该结构，并实现里面的compare方法，该类成为具体策略类；Collections类就是环境角色，他将集合的比较封装成静态方法对外提供api。

* 在Java SE开发中，用户需要对容器对象Container中的成员对象如按钮、文本框等GUI控件进行布局(Layout)，在程序运行期间由客户端动态决定一个Container对象如何布局，Java语言在JDK中提供了几种不同的布局方式，封装在不同的类中，如BorderLayout、FlowLayout、GridLayout、GridBagLayout和CardLayout等。


## 观察者模式

在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖他的对象都会收到通知并自动更新。体现封装变化、针对接口编程、多用组合，少用继承、交互对象之间的松耦合设计

类图：

![类图](https://github.com/zhongyp/zhongyp.github.io/blob/master/files/observer.png?raw=true)

观察者模式的效果有以下的优点：

* 观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。

* 由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。

* 观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知，

观察者模式有下面的缺点：

* 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。

* 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。

* 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。

* 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。

应用场景：

spring的事件驱动模型使用的是观察者模式，通过ApplicationEvent抽象类和ApplicationListener接口,可以实现ApplicationContext事件处理，监听器在处理Event时,通常会进行判断传入的Event是不是自己所想要处理的,使用instanceof关键字，ApplicationEventMulticaster事件广播器实现了监听器的注册,一般不需要我们实现,只需要显示的调用applicationcontext.publisherEvent方法即可。

## 装饰者模式

动态的将责任附加到对象上，若要扩展功能，装饰者提供了比集成更具有弹性的替代方案。

优点：

* 动态的给一个对象添加一些额外的职责，就扩展功能而言，比生成子类方式更为灵活。

缺点：

* 利用装饰器模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。

应用场景

![IO](https://github.com/zhongyp/zhongyp.github.io/blob/master/files/IO.png?raw=true)

FileInputStream、StringBufferInputStream、ByteArrayInputStream为被装饰的组件类。

PushbackInputStream、BufferInputStream、DataInputStream、LineNumberInputStream为具体装饰者类。

## 工厂模式

三种形态：

* 简单工厂模式：又称静态工厂方法

* 工厂方法模式：又称多态性工厂模式或虚拟构造子模式

* 抽象工厂模式：又称工具箱模式


简单工厂模式：专门定义一个类来负责其他类的实例，被创建的实例通常具有共同的父类或接口。

类图

![简单工厂模式](https://github.com/zhongyp/zhongyp.github.io/blob/master/files/Annimal.png?raw=true)

适用场景：

工厂类负责创建的对象比较少：由于创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂；
客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数；

优点：

* 工厂类含有必要的逻辑判断，可以决定什么时候创建哪一个产品实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品：简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象；
* 客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量；
* 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程序上提高了系统的灵活性。

缺点：

* 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响；
* 使用简单工厂模式将会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解难度；
* 系统扩展困难，一旦添加新产品，就不得不修改工厂逻辑，在产品类型较多时有可能造成工厂逻辑过于复杂不利于系统的扩展和维护；
* 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。
 

工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。

在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作子类去做，这个核心类则成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。

![类图](https://github.com/zhongyp/zhongyp.github.io/blob/master/files/simplefactory.png?raw=true)

适用场景：

* 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要指定具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端只需要知道创建具体产品的工厂类；
* 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏替换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展；
* 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时无需关心哪一个工厂子类创建产品，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

优点：

* 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏具体产品类将被实例化这一细节，用户只需关心所需产品对应的工厂，无需关心创建细节，甚至无需知道具体产品类的类名；
* 基于工厂角色和产品角色多态性的设计是工厂方法模式的关键，它能够使工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装到具体工厂内部。工厂方法模式，又称为多态性工厂模式，正是因为所有的具体工厂类都具有同一抽象父类；
* 使用工厂方法模式在系统中加入新产品时，无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其它的具体工厂和具体产品，而只需要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。


缺点：

在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销；
由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到反射机制等技术，增加了系统的实现难度。
 

抽象工厂模式：提供一个创建一系列或相互依赖的对象的接口，而无需指定它们的具体类。

![类图](https://github.com/zhongyp/zhongyp.github.io/blob/master/files/abstractfactory.jpg?raw=true)

适用场景：

一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的；
一个系统有多于一个产品族，而系统只消费其中某一族产品；
同属于同一个产品族的产品是在一起使用的，这一约束必须要在系统的设计中体现出来；
系统提供一个产品类的库，所有的产品以相同的接口出现，从而使客户端不依赖于实现；

优点：

* 隔离了具体类的创建，使得用户不需要知道创建的细节；
* 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用一个产品族中的对象；

缺点：

* 添加新的产品对象时，难以扩展抽象工厂以便生成新种类的产品；

## 单件模式

确保一个类只有一个实例，并提供全局访问点。




## 命令模式

将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。



## 外观模式

提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。



## 适配器模式

将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。



## 模板方法模式

在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使用子类可以在不改变算法结构的情况下，重新定义算法中的步骤。



## 迭代器模式

提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。



## 组合模式

允许你讲对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象及对象组合。



## 状态模式

允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。



## 代理模式

为另一个对象提供一个替身或者占位符以控制对这个对象的访问。

优点：

只有真正去调用的时候才会创建实例。有些情况下，程序不会真正的调用被调用对象的某个方法时，这种情况无需去创建被调用这对象的实例。在这种情况下，代理模式可以调程序的性能。宏观上减少了系统开销。

应用：hibernate延时加载

动态代理模式类图

![动态代理模式类图](https://github.com/camda/Demo/blob/master/src/main/resources/images/001.png?raw=ture)

## 复合模式

复合模式结合两个或以上的模式，组合一个解决方案，解决一再发生的一般性问题

## 其他的设计模式

[参考网址](https://www.cnblogs.com/littlejava/p/5701935.html)