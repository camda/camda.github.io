---
layout: post
title: "JVM(Java虚拟机)--摘自《深入理解Java虚拟机》"
date: 2018-03-27 
tag: "JVM"
detail: 
img: 

---

* content
{:toc}

## 运行时数据区域

程序计数器： 当前线程所执行字节码的行号指示器，字节码解释器的作用是通过改变计数器的值来选取下一条需要执行的字节码指令。如果当前执行的是Native方法，则这个计数器为空。Java虚拟机中唯一没有OOM的区域。

Java虚拟机栈：虚拟机栈描述的是Java方法执行的内存模型，生命周期与线程相同。每个方法运行都会创建一个栈帧，存储局部变量表，操作栈，方法出口等信息。局部变量表（编译期分配）存放各种基本数据类型和对象引用类型，returnAddress。

本地方法栈：虚拟机栈为执行Java方法服务，本地方法栈为Native方法服务。

Java堆：虚拟机启动时创建被所有线程共享的内存区域，为了存储所有对象实例。垃圾回收的主要区域。

方法区：各个线程共享的内存区域，存储类信息，静态变量、常量、即时编译器编译后的代码数据。

运行时常量池：方法区的一部分（JDK1.6以前），Java7中已经将运行时常量池从永久代移除，在Java 堆（Heap）中开辟了一块区域存放运行时常量池。Java8中，已经彻底没有了永久代，将方法区直接放在一个与堆不相连的本地内存区域，这个区域被叫做元空间。 类加载后存储编译器生成的各种字面量和符号引用。基本数据类型不叫常量，可被修改，String和final修饰的才是。

直接内存：堆外内存，可能会导致OOM。

## 对象状态算法

引用计数算法： 很难解决对象之间相互引用的问题，内存泄露。

跟搜索算法：通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索的路径成为引用链，当一个对象到GC Root没有一个引用时，则证明此对象是不可用的。

注：GC对象包括：虚拟机栈（本地变量表）中引用的对象，方法区中类静态属性引用的对象，方法去中常量引用的对象，本地方法栈中JNI。

跟搜索算法中，没有引用的对象并非非死不可，还有经历两次标记，第一次发现没有引用，则进行标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或finalize()已经被调用过，虚拟机将这两种情况都视为没有必要执行。

回收方法区： 回收废弃变量和无用的类，无用的类：该类所有实例都已被回收，加载该类的ClassLoader被回收，该类对应的java.lang.Class对象没有在任何地方被引用。反射、代理、bytecode框架需具备卸载功能。


## 垃圾收集算法

标记清除算法： 标记所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。效率问题，空间问题（内存碎片）。

复制算法： 将可用内存按照容量分为大小相等的两块，每次只是用其中的一块。当这块用完了，就将存活的对象复制到另一块上面，然后再把已经使用过的空间清理掉。新生代（EDEN）使用复制算法，当回收时，将Eden和Survivor中还存活的对象一次性的拷贝到另一块的Survivor上。最后清理掉Eden和刚才使用过的Survivor。

标记-整理算法：让所有存活的对象向一端移动，然后清理掉端边界以外的内存。

分代收集算法： 根据对象的存活周期不同，将内存划分为几块，根据各个年代的特点进行垃圾回收。

## 垃圾收集器

如果两个收集器之间存在连线，就说明他们可以搭配使用。

1. Serial

    新生代的单线程收集器，简单高效，运行时停掉其他所有线程。
    
2. ParNew

    Serial多线程版本，首选的新生代收集器。
    
3. Parallel Scavenge

    新生代收集器，使用复制算法，并行线程。目标达到可控制的吞吐量。运行用户代码时间/CPU消耗总时常=吞吐量。
    
4. Serial Old

    Serial收集器的老年代版本，单线程收集器，使用标记-整理算法。
    
5. Parallel Old

    老年代版本，标记-整理算法。

6. CMS收集器

    最短回收停顿时间为目标的收集器，重视服务响应速度，标记-清除算法实现。第一款并发收集器，可与用户线程
    
    初始标记、并发标记、重新标记、并发清除。初始和重新stop the world。初始标记只是标记GCRoots能直接关联的对象，速度很快，并发标记进行GCROOTs Tracing的过程。重新标记为了修复并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。
    
    缺点：1. 对CPU资源非常敏感，解决方案，减少GC线程的独占时间。2. 无法处理浮动垃圾。如果CMS运行期间，内存无法满足要求，出现Concurrent Mode Failure失败导致另一个FullGC产生，启动预备方案 Serial Old。CMS运行期间，用户线程产生的垃圾为浮动垃圾，CMS无法在本次收集中个清理这些浮动垃圾。3. 产生大量的空间碎片。
    
7. G1收集器

    标记整理算法实现，精确的控制停顿。G1将整个Java堆（老年代，新生代）划分多个大小固定的独立区域，并且追踪这些区域里面的垃圾堆积程度。在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。
    
## 内存分配与回收

对象在Eden中分配内存，没有足够的空间进行垃圾回收。MinorGC。

    MinorGC: 新生代垃圾回收的动作，频繁且速度快。

    MajorGC（FullGC）: 指发生在老年代的GC，慢，清理新生代和老年代，CMS

大对象指需要大量连续空间的Java对象。典型就是很长的字符串和数组。直接进入老年代分配，避免在Eden及Survivor中大量复制拷贝。

长期生活的对象进入老年代。对象年龄计数器，每一次MinorGC增长1岁。默认15岁进入老年代。

动态对象年龄判断，如果在Survivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄段的对象直接进入老年代。

空间担保分配，每次MinorGC,检测升级到老年代的大小是否大于老年代的空间，如果大于，则进行FullGC。

## JDK命令行工具 性能监控和故障处理

jps： 虚拟机进程状况工具。 显示当前所有java进程pid的命令。

jstat: 虚拟机统计信息监视工具，用于监视虚拟机各种运行状态信息的命令。可以显示本地或远程虚拟机进程中的类加载、内存、垃圾回收、JIT编译等运行数据。运行期定位虚拟机性能问题的首选工具。

jinfo: 实时的查看和调整虚拟机的各项参数。

jmap: Java内存映像工具。用于生成堆转储快照，还可以查询finalize()执行队列，Java堆和永久代的详细信息，如空间使用率、当前使用的哪种收集器等。

jhat: 分析jmap生成的堆转储快照，在浏览器查看。

jstack： 用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条正在执行的方法堆栈的集合，生成快照的目的是定位线程出现长时间停顿的原因。


## JDK可视化工具

JConsole: Java监视与管理控制台。基于JMX的可视化监视和管理工具。监视Java堆和永久代的的变化趋势。

VisualVM: 多合一故障处理工具。


## 高性能硬件上的程序部署策略

使用64位JDK大内存。

问题：1.内存回收导致长时间停顿。2.64位JDK的性能测试结果普遍低于32位JDK。3.需要保证程序足够稳定，这种应用如果产生堆溢出几乎就无法产生堆转储快照。4. 相同程序64位JDK中消耗内存一般比32位大，这是由于指针膨胀和数据类型对其补白导致的。

使用若干个32位虚拟机建立逻辑集群来利用集群资源。

问题：1.尽量避免节点竞争全局资源，如并发写操作导致IO异常。2.很难高效率的利用某些资源池，比如连接池，导致一些节点满了，其他的还为零。3.各个节点仍然不可避免的受到32位的限制（2GB）。4.大量使用本地缓存的应用，改为集中式的缓存。


## 集群间同步导致内存溢出


## 堆外内存导致的溢出错误

## 外部命令导致系统缓慢





